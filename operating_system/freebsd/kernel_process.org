* FreeBSD process

** 内核服务
   
*** 内核元素

    用户进程 -> 系统调用, 中断, 陷阱 -> 内核例程 -> 返回用户进程

**** 进程

     内核的一些进程:
    
    - audit, 审计
    - bufdaemon, 清除脏缓冲区
    - crypto, 加密解密
    - geom, 配置任务(g_event), 设备进入进程的数据处理(g_up), 进程往设备的数据处理(g_down)
    - idle
    - intr, 每个硬件中断对应一个进程
    - pagedaemon, 进程部分写入辅存
    - syncer, 脏文件的数据写入
    - vmdaemon, 资源不足时, 把整个进程从主存转移到辅存
    - vnlru, 对最近最少使用的 vnode 进行清理, 以维持空闲 vnode 的数量
    - yarrow, 收集随机数据, 提供随机种子

**** 系统入口

     - hardware interrupt, 硬件中断
     - hardware trap, 硬件陷阱
     - software-initiated trap, 软件陷阱

     运行时, 通常分为上班步和下半部.

      - 上半部内核
          
        向进程提供服务, 对系统调用和陷阱进行响应;
        在特权模式下运行, 既可以访问内核数据解构, 也可以访问用户级别上下文;
        进程上下文包括两个内存区域,
        
            1. process structure(进程解构), 保存被换出后仍需要保存的信息;
                 如: 进程关联的标识符, 进程的权限, 进程描述符, 内存映射, 未处理的外部事件, 等等
            2. thread structure(线程解构), 保存进程被换出后不需要的信息;
                 如: 硬件TSB(Thread State Block), 内核堆栈, 调试和创建coredump需要的信息

      - 下半部内核
        
        由负责处理硬件中断的例程组成.

**** 内核入口

     进程通过陷阱和中断进入内核, 内核必须保存当前机器的状态, 如: 程序计数器, 用户堆栈指针, 通用寄存器等;
     
**** 系统调用

     主要完成两个工作:
     
       - 检测系统调用的参数是否位于有效的用户地址中, 并将他们从用户空间复制到内核中
       - 调用系统调用例程

     调用不成功有两种可能

       - 有错误
       - 被中断

     系统调用退出时:
     
       - 检查进程是否收到过信号
       - 检查是否有哪个进程优先级比当前更高
       - 如果进程要求提供 profiling(剖析数据), 退出时计算系统调用所花的时间总量.

**** 陷阱

     陷阱(Trap)与系统调用一样, 他的出现也是与进程同步的, 一般因为发生了意外的错误;

     保持进程状态 -> 确定陷阱类型 -> 确认发信号或页面调入请求(pagein) -> 返回时检查未处理信号或者高优先级进程
     
**** 软件中断

     收到数据包, 通过硬件中断驱动; 接下来, 将数据包传递给进程的工作, 费时但不紧急, 可以分配低优先级;
     这种低优先级处理的机制叫做软件中断( software interrupt ).

**** 时钟中断

     系统由时钟驱动, 时钟以固定的间隔产生中断, 每一次中断为一个节拍( tick );

     PC上一般每秒 1000 次, 但每秒处理1000个中断非常耗时耗力, 通常中断处理比1000 低得多;
     内核会计算将来可能需要执行某个操作的节拍数, 安排下一个时钟中断在那个时间发生;

     时钟中断有很高的硬件中断优先级, 调用 hardclock(),需要很快执行完;
     时间要求不严格的工作将交给 softclock() ;

     除了系统时钟, 还有
       - statclock(), 每秒 127
       - profclock(), 每秒 8128

     softclock 处理超时请求, 以及定期为待运行的进程重新设置优先级.

     callout 队列: 等待事件的数据解构:

     now + 199
     now       -> now  -> now + 200 -> now
     now + 1
     now + 2
     ...
    
**** 进程的内存布局
     
     [[./img/process-mem-layout.png][mem_layout]]
    
**** 时间服务

     gettimeofday 返回 UTC 时间 1970-1-1 起的偏移

     调整时间时, 使用settimeofday 会使那些时间快的机器出现时间倒退, 进而使一些时间递增程序(如:make)感到迷惑;
     为了避免这个问题, 系统提供了adjtime,  通过更改时钟速度, 逐步纠正时间; 对测量时间间隔的程序有影响.

     3个定时器:
       - real timer
       - profiling timer
       - virtual timer

**** 资源服务

     进程优先级:  nice值, 通常为0, 负的表示想要多占cpu时间, 正的表示想要少占时间;
     还有实时调度算法

     getrusage, 返回一个进程使用的资源情况;

***** 资源限制

      可以限制以下资源:
        - 积累的最长 CPU 时间
        - 进程驻留内存最大字节数
        - 数据段最大值
        - 堆栈段最大值
        - 最大私有物理内存量
        - 最大私有或共享内存量
        - 套接字缓冲区的最大物理内存量
        - 能创建的最大文件
        - 能创建的最大核心文件
        - 同时打开的文件数
        - 同时运行的最大进程数
     
     
        
** process

   进程可以在用户态和内核态运行.

*** 调度

    分时:
      time-shared scheduling;
      基于优先级的策略, 优先照顾交互式程序;
      用外时间片的, 降低优先级,  没有用完就交出控制的, 优先级不变;
    
    
    实时:
      real-time scheduling;
      使用独立的队列来实现实时, 实时优先级的进程不会被降低优先级;
      只能被实时优先级高的抢占

    空闲:
      idle 线程维护了一个队列


    thrashing(颠簸, 抖动):
      内存不足时, 需要保证时间不是消耗在处理缺页和调度进程上

*** 进程, 线程

**** 进程结构

     - 进程标识
     - 信号状态
     - 跟踪信息
     - 定时器
     - 用户凭证
     - 内存管理
     - 文件描述符
     - 系统调用向量
     - 资源记账
     - 统计信息
     - 信号动作
     - 线程解构


    状态state:  
    #+begin_src C
      enum p_states {
        PRS_NEW = 0,            /* In creation */        
        PRS_NORMAL,             /* threads can be run. */
        PRS_ZOMBIE
      } p_state;                      /* (j/c) Process status. */
      #+end_src
     
    run queue:
      运行队列;
      可运行状态

    sleep queue:
      休眠队列
      阻塞或休眠

    turnstile:
      

    priority:

      Priorities range from 0 to 255, but differences of less then 4 (RQ_PPQ)
      are insignificant.  Ranges are as follows:                                                                                                 
                                                                                                                                              
      Interrupt threads:           0 - 47                                                                                                        
      Realtime user threads:       48 - 79                                                                                                       
      Top half kernel threads:     80 - 119                                                                                                      
      Time sharing user threads:   120 - 223                                                                                                     
      Idle user threads:           224 - 255 
    
**** 线程结构

     - 调度机制
     - TSB, thread state block 
     - 内核栈
     - 机器状态


**** 上下文切换

     主动上下文切换:  等待某个事件; \\
     被动上下文切换:  时间片用完;


     - 内核态硬件执行状态:  只能在内核态发生上下文切换, TSB
     - 用户态硬件执行状态:  当在内核态执行时, 线程用户状态总是保存在位于线程解构的内核执行栈中
     - 进程结构: 驻留内存
     - 内存资源: TSB中内存管理寄存器以及进程和线程结构中的一些值能有效描述资源, 驻留内存即有效, 交换后需重新计算


    短期等待仅由锁请求引起, 包括互斥锁, 读写锁和只读锁.

    短期锁定由旋转数据解构管理.

    每个线程分配一个闸机.

    优先级反转: 当持有短期锁的线程优先级低于自己的优先级时, 发生反转.

    中期和长期锁上阻塞的进程, 使用休眠队列;
    并且, 可以申请timeout, 到期时, 线程将被唤醒并返回错误消息.

    挂起线程的操作:
      - 防止可能导致线程状态转换的事件; 以前, 全局调度锁, 现在, 当前状态锁(队列锁, 闸机锁, 等待通道hash链锁)
      - 记录线程结构中的等待通道, 求hash, 来检查是否存在等待通道的闸机或休眠队列
      - 对于放在闸机上的线程, 当前优先级高于持有锁的线程优先级, 则传递优先级;
        对与休眠队列上的线程, 将线程优先级设置为唤醒线程时要具有的优先级, 并设置休眠标志
      - 对于放在闸机上的线程, 将其分类到等待线程列表中, 使优先级高的在第一位
        对于放在队列上的线程, 将其放在等待该通道的线程列表末尾
      - 调用 mi_switch()以请求安排新线程;
     
**** 同步

     临界区: 最简单的同步机制;

     当线程在临界区运行时, 既不能被转移到另一个cpu上, 也不能被另一个线程抢占;
     临界区保护每一个cpu的数据结构, 例如: 运行队列或特定CPU的存储分配结构;

     临界区首先调用 critical_enter(), 然后继续调用 critical_exit();

     硬件需要提供内存互锁的 compare-and-swap 指令;
     指令在一个主存位置上完成两个锁操作--先读取再比较, 然后看是否能与比较的值匹配;
     如果匹配, 写入新值, 期间其他任何处理器不可以读写这个内存位置;

     FreeBSD 的锁源语都使用 compare-and-swap 指令构建.

**** 互斥同步锁

     mutex (互斥锁) 时保持短期线程同步的基本方法;

     两种风格的互斥锁, 阻塞与不阻塞; 默认阻塞, 也就是大多数内核代码使用阻塞的锁;
     当线程在无法获得锁的情况下挂起;

     spin mutex, 不休眠的互斥锁;

     自旋互斥锁比非自旋锁的代价更大;
     持有时,需要禁用或延迟中断,以防止与中断处理代码的竞争, 会增加中断延迟;

     FreeBSD 只在执行低级调度和上下文切换的代码中使用自选互斥锁;

     单处理器上不适合自旋互斥锁;
     因为要让n另一个线程释放一项资源, 唯一的途径就是让那个线程开始运行;
     所以单处理器上自旋互斥锁必定会转为休眠锁;
     持有时中断被禁用, 由于没有其他处理器进行中断, 中断延迟会更明显;

     参考: man 9 locking
     
     
***** 接口

      kern_mutex.c
      
      mutex_init 进行初始化;
      没有 mtx_destroy 就不允许同一个互斥锁传给 mtx_init

      mtx_lock 为当前运行的进程申请一个互斥锁;
      如果另一个进程持有该锁, 调用这个函数会进入休眠,直到可以获取该锁;

      mtx_lock_spin 不进行休眠而是自旋, 进入一个临界区, 释放时退出临界区;
      持有该锁的cpu 会禁止中断, 期间其他线程(包括中断)不能在该cpu上运行;

      mtx_trylock 尝试为当前正在运行的线程上一个互斥锁;
      不能获得时,返回0

      互斥锁占用空间大, 内核提供了一种互斥锁池;
      可参考 poll 的代码
      
      
**** 锁同步

     进程间对资源的同步, 一般是通过把它和一个锁结构联系起来的方法实现的;
     内核有一个锁管理器(lock manager)来操控一个锁:
       - 请求共享
       - 请求独占
       - 请求释放
       - 请求升级
       - 请求独占升级
       - 请求降级
       - 请求停用(drain)

**** 死锁预防

     1. 一个线程只能获得一个类型的锁
     2. 线程要获得一个类型的锁, 这个锁的类型号必须高于该线程已持锁的最高号


     witness, 强制执行锁的优先级次序.

*** 线程调度

    编译时选择调度器, 节约开销;

    调度器分两级:
      - 低级, 简单运行频繁
      - 高级, 复杂,每秒做多运行几次

    每个 cpu 都有一组运行队列, 按优先级从高到低进行组织;
    线程阻塞时, 低级调度器从 该 cpu 的非空的最高优先级队列中选择线程;

    高级调度器负责设置线程的优先级, 并决定应将他们加入哪一个运行队列;

    线程阻塞, 放到闸机或休眠队列;
    线程时间片(slice)用完, 放到原来队列末尾

    分时线程优先级, 120-223；
    实时线程优先级, 48-79;

    系统使用64个运行队列, 线程优先级i除以4的商来选择;

    每个队列的首项放在一个数组中,
    数组关联一个位向量(bit vector) rq_status,
    用这个判断队列是否为空;
    runq_add 和 runq_remove, 分别用于置于队列末尾和取出;

    核心算法是 runq_choose:
       - 确保获得运行队列相关的锁
       - rq_status 中第一个非0位,  等于0选择 idle loop
       - 找到的非空队列, 取出第一个线程
       - 取出后如果队列为空,重新设置 rq_status
       - 返回被选出的线程

    上下文切换有两部分, 机器无关的在 mi_switch, 机器有关的在 cpu_switch(汇编)

    
**** 多处理器

     9.0 之后新调度器开发为了解决以下问题:
       - 亲和性需求
       - cpu之间负载均衡
       - 单芯片,多cpu的更好支持
       - 提高调度算法的性能, 从而使性能不再依赖与系统中的线程数量
       - 交互性和分时性

     评估交互性的算法叫做交互性得分, 是资源性休眠时间和正常运行时间的比率, 1-100;

     交互性得分与交互性阈值比较, 阈值由进程的nice值修改, 正的难以被认为是交互的

     cpu 利用率以时间刻度(1ms)记录在线程中;
     调度器试图保存10s的历史记录,


     日历队列(系统调用轮)

     每个cpu 都有三个数组队列, 空闲队列, 实时队列, 分时队列;
     线程如何插入分时队列, 是根据优先级和最高分时优先级之间的差决定的;

     sysctl kern.sched 树来实时探索控制这些算法限制的许多参数;
     其余是常量, 记录在 /sys/kern/sched_ule.c


     多处理器感知处理决策;

     cpu 拓扑以任意深度的树的形式实现;
     cpu_search 来解析, 它是路径感知, 基于目标的树遍历函数, 可以从任意子树开始;

     当线程被唤醒,解锁,创建或者其他事件而变为可运行状态时, 会调用 sched_pickup()

     另一个多处理调度算法在cpu空闲时运行, 在掩码中设置一个位, 标识空闲

     还有一个多处理算法是长期负载均衡, 被称为推送迁移, 系统定期执行;

     传统分时调度时以"多级反馈队列"为基础;

     
*** 创建和终止进程

    使用 fork 创建进程;
      - fork , 创建一个完整的副本
      - rfork, 新进程和父进程共享一组指定的资源
      - vfork, 处理虚拟内存资源的时候, 与fork不同, 而且保证新进程调用exec和exit前,
        新进程不会运行

    终止进程:
      - 正在进入内核里面时, 都要调用thread_exit() 来终止;
      - 已经在内核中, 并试图进入休眠的任何线程都会立即以EINTR或者EAGAIN返回,
        迫使返回用户空间, 并释放资源, 离开内核时, 碰到exit调用

    wait4 调用会获取进程的资源使用状况, 分析长期运行的进程时, 除了这个, 没有其他api;

*** 信号        

    围绕 虚拟机(virtual-machine)模型来设计, 将系统调用和硬件指令集对等看待;
    信号在软件角度上等同于陷阱或者中断.

    psignal 发送单个进程;
    gsignal 发送给一组进程;

    系统调用返回时, 会调用 cursig 检查是否有等待的信号;
    cursig 检查信号的列表, p_siglist;
    判断是否有应该传递到线程的信号列表 tg_siglist 的信号;
    如果线程挂起, 并且必须在线程上下文中传递, 那么将它从挂起的集合中移除, 并调用 postsig来 执行相应操作

    进程只能向有着相同有效 UID 的进程发送信号;
    
    SIGCONT: 可以由一个进程发送给它所有的后代进程;

    一些系统调用:
      sigprocmask: 更改线程屏蔽的一组信号;
      sigsuspend:  让线程放弃处理器, 直到接受到一个信号为止;
      sigaltstack: 让进程指定一个运行时堆栈用于信号发送;
      sigreturn:

**** 发送信号

     psignal() 将信号发送到单个进程;

*** 进程组和会话

    process group 相关进程的集合;

    会被赋予同一个进程组号, process-group identifier

    进程可以创建新进程组 或者 setgpid

    会话, session, 主要用途是将一个用户的登录shell 以及由shell所创建的作业集中在一起;

*** 作业

    每个作业都是一个进程组;

    通过 killpg 来向作业发送信号控制


    
      
    
    
     
     
    

    
     
      
      

     
     
     
       
    
      

    
     
